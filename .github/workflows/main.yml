name: Docker镜像在线打包成离线包

on:
  workflow_dispatch:
    inputs:
      docker_images:
        description: '请填写 Docker 镜像名称 (多个用英文逗号分开)'
        required: true
        default: 'alpine:latest'
      custom_name:
        description: '可选: 自定义发布名称'
        required: false
      tag:
        description: '可选: 发布标签 (默认为当前日期)'
        required: false

jobs:
  pull_and_package:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Create builder and use it
      run: |
        docker buildx create --use

    - name: Install QEMU for multi-arch support
      uses: docker/setup-qemu-action@v2

    - name: Clean up Docker to free space
      run: |
        docker system prune -a -f
        docker volume prune -f

    - name: Pull and Save Multi-Arch Docker Images
      run: |
        images="${{ github.event.inputs.docker_images }}"
        IFS=',' read -r -a image_array <<< "$images"
        for image in "${image_array[@]}"; do
          # 获取镜像名称和版本
          image_name="${image%%:*}"  # 镜像名称
          image_tag="${image##*:}"   # 镜像标签
          
          # 如果标签是latest，不在文件名中显示标签
          if [ "$image_tag" = "latest" ]; then
            file_name="${image_name}.tar"
          else
            file_name="${image_name}_${image_tag}.tar"
          fi
          
          # 拉取镜像并保存为文件
          docker pull "${image}"
          docker save "${image}" -o "${file_name}"
        done

    - name: Compress the TAR files
      run: |
        # 使用 release 名称作为文件名
        tar -czf "${{ env.RELEASE_NAME }}.tar.gz" *.tar

    - name: Get release name and tag
      run: |
        # 检查是否提供了自定义名称
        if [ -z "${{ github.event.inputs.custom_name }}" ]; then
          # 如果未提供自定义名称，使用第一个镜像的名称作为默认名称
          images="${{ github.event.inputs.docker_images }}"
          IFS=',' read -r -a image_array <<< "$images"
          image_name="${image_array[0]%%:*}"  # 第一个镜像名称不带版本号
          echo "RELEASE_NAME=${image_name}" >> $GITHUB_ENV
        else
          # 使用用户提供的自定义名称
          echo "RELEASE_NAME=${{ github.event.inputs.custom_name }}" >> $GITHUB_ENV
        fi
        
        # 检查是否提供了标签
        if [ -z "${{ github.event.inputs.tag }}" ]; then
          # 如果没有提供 tag，使用当前日期作为 tag
          echo "RELEASE_TAG=$(date +'%Y%m%d')" >> $GITHUB_ENV
        else
          # 使用用户提供的 tag
          echo "RELEASE_TAG=${{ github.event.inputs.tag }}" >> $GITHUB_ENV
        fi

    - name: Compress the TAR files (final step)
      run: |
        # 压缩所有镜像文件为 release 名称的 tar.gz 包
        tar -czf "${{ env.RELEASE_NAME }}.tar.gz" *.tar

    - name: Upload artifact to GitHub Release
      uses: ncipollo/release-action@v1
      with:
        artifacts: "${{ env.RELEASE_NAME }}.tar.gz"  # 使用动态文件名
        token: ${{ secrets.GITHUB_TOKEN }}
        tag: ${{ env.RELEASE_TAG }}  # 使用提供的标签或默认日期作为 tag
        name: ${{ env.RELEASE_NAME }}  # 使用镜像名称或者自定义名称作为 release 名称
        body: "These are the saved multi-architecture Docker images."
        draft: false
        prerelease: false

    - name: Clean up intermediate files
      run: |
        rm *.tar
